# File Centric Web Apps

This example application implements a tiny spreadsheet application.
You can create new files online, save them either to your own workstation or to browsers local storage, open them from your own workstation or from local storage.

The app is using a (commercial) [Vaadin Spreadsheet](https://vaadin.com/docs/latest/components/spreadsheet) component to implement the actual "spreadsheet part" and there is an online version of this [deployed on a tiny demo server](http://vaadin-e-xell.dokku1.parttio.org/). But the main point of the example is not to brag with the component that implements the spreadsheet editor with a one-liner. Use Google Sheets if you need a proper online spreadsheet application.

The **beef of this example is how the data is handled**. In typical web apps the database is a central part of your application where pretty much all data is saved. In this web app, there is no database, it doesn't store anything on the filesystem, RDBMS nor to AWS S3 or similar. Users files are exist on their own workstations, either on their normal file system or in their browser's local storage. The example demonstrate both the universal architectural approach where no data is saved on the server and the best practices to implement the actions with Java in JVM server using Vaadin.

The fact that there is no persistence on the server naturally simplifies the architecture quite a bit. In this app we get the spreadsheet data serialized to bytes by Apache POI (that is used by Vaadin Spreadsheet), but in more typical cases you would use for example JSON, XML, standard Java serialization or e.g. [Eclipse Serializer](https://vaadin.com/blog/you-might-not-need-the-database) to store custom data structures. It is not only about *not needing Hibernate*, but for example there is no need to add authentication & authorization - data don't need to be associated to any specific user(s). Not to mention that you might be able to workaround some nasty legal restrictions...

I have used this pattern as a developer and consumer and I think it should get a bit more exposure among web developers. It suits very well for cases where sharing, collaboration or access to your files from any browser is not needed. Also, the datasets that are handled in the app needs to be somewhat limited or at least in balance with your network connection. It is for example a good fit for various utility apps, whose data sets are not in the cloud.

While this example runs in a JVM server, the same approach can be used in pure client-side apps as well. The [File API](https://developer.mozilla.org/en-US/docs/Web/API/File), nowadays available in all modern browsers, technically allows you to read (and write) the file contents also using a JavaScript API. Naturally, with this approach you have a rather limited execution environment (browsers sandbox) compared to the superpowers of your server (any programming language, as much memory and CPUs as you can afford).

Some code highlights from the example app:

 * **Downloading the spreadsheet file from a server to a workstation aka "Save" action.** 
   https://github.com/mstahv/e-xell/blob/250923402f26ae0fc3d94daeccb8721f92d6d6c8/src/main/java/org/example/views/MainView.java#L39-L41
   Like most libraries the Spreadsheet component (and the underlying [Apache POI](https://poi.apache.org) library) writes the content to [OutputStream](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/OutputStream.html). The [DynamicFileDownloader component](https://vaadin.com/directory/component/flow-viritin) eats a lambda expression that is executed when the user clicks the button (technically an "A" tag). It is enough to simply pass the provided output stream to the Spreadsheet component. The bytes generated by POI are then written directly to the output stream, and finally written by the browser to a file on the end users file system. No extra buffers (memory or files) are needed.
 * **Uploading the file from the workstation to teh server aka "Open" action.**
   https://github.com/mstahv/e-xell/blob/539448c66317bec97eeeda4a4cb3f3dfa7d041ec/src/main/java/org/example/views/MainView.java#L34-L42
   This is the opposite to the previous point. The [UploadFileHandler](https://vaadin.com/directory/component/flow-viritin) component needs an action that consumes an [InputStream](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/InputStream.html). In addition, it gets some metadata about the file, like the name of the file in the user's filesystem, but those are not needed in this example. In the example a instantiate a new Spreadsheet component gets instantiated that initializes its state from the contents of the file chosen by the user. Again no extra buffers needed. By default, the component also supports drag and dropping files, but the component would then be bit too large for out "toolbar". Thus, disabling the drag and drop area and making it appear only as an icon, like the DynamicFileDownloader defaults to.
 * **Saving to the browsers WebStorage**
   https://github.com/mstahv/e-xell/blob/250923402f26ae0fc3d94daeccb8721f92d6d6c8/src/main/java/org/example/views/WebStorageFilePicker.java#L134-L146
   The actual UI code in the MainView is quite similar to the normal download discussed above. Instead of a file download we show a button that saves the content to the [browsers WebStorage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API). The [Java API around the WebStorage API](https://vaadin.com/docs/latest/advanced/web-storage-api) has been shipped with Vaadin core since version 24.2.0, before that you needed to drop in [a community supported add-on](https://vaadin.com/directory/). In the example all the WebStorage access is separated to a generic helper class, that could in theory be re-used in other apps as well. The relevant part of it is shown above. As the WebStorage API in browsers is essentially a strint-string map, the helper class does Base64 encoding for the binary data. Before Base64 encoding, we also pass the byte stream through GZIPOutputStream to compress it. I didn't check if it really helps with these file (might be compressed already), but added it as an example as the default maximum space (per domain) in "local storage" is "just" 5 megs. Depending on your use case, it may be a lot or not.
 * **Reading the file input from the browsers WebStorage** 
   https://github.com/mstahv/e-xell/blob/main/src/main/java/org/example/views/WebStorageFilePicker.java#L162-L182
   Reading from WebStorage is symmetric to the previous point. The helper first shows a dialog that allows user to choose from previously known "file names" (which are technically just keys into WebStorage). Once the key is chosen, its value is decoded and the gzip compression is removed, before it is passed back to the application (and ultimately to Vaadin Spreasheet component and the POI library.

As a summary, here are some pro's and con's of this kind of web apps:

 * No need for a database.
 * No need for JPA or any other persistence libraries.
 * No hassle in deployment to connect the application server to the database.
 * No need to implement authentication to your application. Your users files are controlled by your users.
 * Sharing files with other users is both harder and more complex. In this example files only live shortly during the session in the JVM memory, associated to an open browser window, making it pretty much impossible to share the file permanently with others via server. But on the other hand, files can be sent as an email attachments or on floppy disks and even backed up on tape ðŸ¤“ And it is harder for non-skilled users to accidentally share important documents to the whole world ("to anyone with a link"), that is proven to happen with e.g. Google Docs. Of course, if the device with the browser (or filesystem) gets compromised, or the application server's RAM, this kind of data can get hacked too.

## Running the application
The project is a standard Maven project. To run it from the command line,
type `mvn`, then open http://localhost:8080 in your browser.

You can also import the project to your IDE of choice as you would with any
Maven project. Read more on [how to set up a development environment for
Vaadin projects](https://vaadin.com/docs/latest/guide/install) (Windows, Linux, macOS).

## Deploying to Production
To create a production build, call `mvn clean package -Pproduction`.
This will build a JAR file with all the dependencies and front-end resources,
ready to be deployed. The file can be found in the `target` folder after the build completes.

Once the JAR file is built, you can run it using
`java -jar target/myapp-1.0-SNAPSHOT.jar` (NOTE, replace 
`myapp-1.0-SNAPSHOT.jar` with the name of your jar).

## Project structure

- `MainView.java` in `src/main/java` is an example Vaadin view.
- `src/main/resources` contains configuration files and static resources
- The `frontend` directory in the root folder is where client-side 
  dependencies and resource files should be placed.

## Useful links

- Read the documentation at [vaadin.com/docs](https://vaadin.com/docs).
- Follow the tutorials at [vaadin.com/tutorials](https://vaadin.com/tutorials).
- Watch training videos and get certified at [vaadin.com/learn/training]( https://vaadin.com/learn/training).
- Create new projects at [start.vaadin.com](https://start.vaadin.com/).
- Search UI components and their usage examples at [vaadin.com/components](https://vaadin.com/components).
- Find a collection of solutions to common use cases in [Vaadin Cookbook](https://cookbook.vaadin.com/).
- Find Add-ons at [vaadin.com/directory](https://vaadin.com/directory).
- Ask questions on [Stack Overflow](https://stackoverflow.com/questions/tagged/vaadin) or join our [Discord channel](https://discord.gg/MYFq5RTbBn).
- Report issues, create pull requests in [GitHub](https://github.com/vaadin/).
